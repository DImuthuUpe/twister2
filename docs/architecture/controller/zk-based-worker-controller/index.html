<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>architecture/controller/zk-based-worker-controller · Twister2</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="# ZooKeeper Based Worker Controller"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="architecture/controller/zk-based-worker-controller · Twister2"/><meta property="og:type" content="website"/><meta property="og:url" content="https://twister2.org/"/><meta property="og:description" content="# ZooKeeper Based Worker Controller"/><meta property="og:image" content="https://twister2.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://twister2.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://twister2.org/blog/atom.xml" title="Twister2 Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://twister2.org/blog/feed.xml" title="Twister2 Blog RSS Feed"/><link rel="stylesheet" href="/css/code-blocks-buttons.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat|Oswald|Roboto&amp;display=swap"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/code-blocks-buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/logo_large.png" alt="Twister2"/><h2 class="headerTitleWithLogo">Twister2</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/introduction" target="_self">Docs</a></li><li class=""><a href="/docs/download" target="_self">Download</a></li><li class=""><a href="http://twister2.org" target="_self">GitHub</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">architecture/controller/zk-based-worker-controller</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="zookeeper-based-worker-controller"></a><a href="#zookeeper-based-worker-controller" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ZooKeeper Based Worker Controller</h1>
<p>We designed a worker discovery, synchronization and ID assignment system for multi-worker jobs in cluster environments that use a ZooKeeper server.</p>
<p>We developed the following class:</p>
<pre><code class="hljs css language-text">edu.iu.dsc.tws.rsched.bootstrap.ZKWorkerController
</code></pre>
<p>It implements the interface:</p>
<pre><code class="hljs css language-text">edu.iu.dsc.tws.common.controller.IWorkerController
</code></pre>
<p>We provide the following services:</p>
<ul>
<li>Assigning unique IDs to each worker from zero and increasing sequentially without any gaps.</li>
<li>Getting the list of all joined workers in a job including the ones that have already left.</li>
<li>Getting the list of all workers in a job, by waiting all workers if they have not joined yet.</li>
<li>Waiting all workers on a barrier point</li>
</ul>
<p>Above services are required by the implemented interface. In addition, ZKController class provides the following service:</p>
<ul>
<li>Getting the list of all currently running workers in a job.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="assumptions"></a><a href="#assumptions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Assumptions</h2>
<p>Each Twister2 job has a unique name: There can not be more than one Twister2 job running in the cluster with the same name.
When we submit a job, if there is already a running job with the same name, that submission must fail.</p>
<p>Each Twister2 job may have any number of workers.</p>
<p>When a Twister2 worker starts in a cluster, it knows its IP address and its port number. Each worker is assigned at least one port number.</p>
<h2><a class="anchor" aria-hidden="true" id="main-idea"></a><a href="#main-idea" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Main Idea</h2>
<p>ZooKeeper keeps data as a tree of znodes. Similar to the file system in computers. Each znode is identified by its path from the root.
Znodes can have children znodes. All znodes can also hold some data.</p>
<p>We create a znode for each job. We use the job name as the znode name, since the job names are unique.
The body of the job znode keeps the list of all joined workers in the job including the ones that have already left.
Job znode keeps worker data as binary encoded protocol buffer messages.
The data of each worker is encoded as a WorkerInfo object defined as a protocol buffer message.
We save each WorkerInfo object length as a 4 byte, then we put encoded the WorkerInfo binary data.<br>
The format of the content of job znode is:</p>
<pre><code class="hljs css language-text"><4 byte WorkerInfo length><binary WorkerInfo message><4 byte WorkerInfo length><binary WorkerInfo message><4 byte WorkerInfo length><binary WorkerInfo message>....
</code></pre>
<p>When a worker joins the job, it first gets its unique ID. Then, it updates the body of the job znode with its data.
It appends its data to the end of the body.</p>
<p>Then, each worker creates a separate child znode under the job znode. The name of the child znode is composed of workerIP and port number:</p>
<pre><code class="hljs css language-text">workerIP:workerPort
</code></pre>
<p>Since workerIP and workerPort pair is unique in each job, this prevents any collusion.
Each worker adds its binary encoded WorkerInfo data as the body data of its znode.
There is no need to save the length of WorkerInfo since this znode has only one WorkerInfo message.</p>
<p>When a worker completes and leaves the job, its child znode is deleted.
However, it does not delete its data from the body of the job znode.
Therefore, children znodes provide data for the current list of workers in a job.
The body of the job znode provides data for all joined workers including the ones that have already left.</p>
<p>The first worker to register with the ZooKeeper server creates the znode for that job.</p>
<h3><a class="anchor" aria-hidden="true" id="removing-worker-znodes-from-zookeeper-server"></a><a href="#removing-worker-znodes-from-zookeeper-server" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Removing Worker Znodes from ZooKeeper Server</h3>
<p>When a worker finishes the computation, its znode should be deleted from the ZooKeeper.
Therefore, we create an ephemeral znode on the ZooKeeper server. When a worker closes its connection to the ZooKeeper server,
its znode is deleted automatically.</p>
<h3><a class="anchor" aria-hidden="true" id="removing-job-znode-from-zookeeper-server"></a><a href="#removing-job-znode-from-zookeeper-server" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Removing Job Znode from ZooKeeper Server</h3>
<p>The job znode can not be ephemeral, since ephemeral znodes can not have children.
Therefore, the last worker to finish computation needs to remove the job znode.
When workers have finished computation, they check whether they are the last worker. If so, they remove the job znode.</p>
<h3><a class="anchor" aria-hidden="true" id="failing-to-remove-the-job-znode"></a><a href="#failing-to-remove-the-job-znode" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Failing to Remove the Job Znode</h3>
<p>When the last worker fails and can not properly complete the computation, it can not delete the job znode.
Then, the job znode may live on the ZooKeeper server after the job has completed.</p>
<p>In another scenario, when a worker fails, ZooKeeper server may take some time to determine that failure.
Currently, it takes 30 seconds for the ZooKeeper server to determine a failed client.
Therefore, failed worker znodes are deleted after 30 seconds.
During this time, if the last worker completes and leaves the job, it thinks that it is not the last worker.
So, it does not delete the job znode. The job znode may live on the ZooKeeper server after the job has finished.</p>
<p>Yet in another case, if the last two workers leave almost at the same time with a few milliseconds apart,
both think that they are not the last one to leave. Since, they have not received the worker leave updates yet.
So, the job znode may not be deleted.</p>
<h3><a class="anchor" aria-hidden="true" id="what-happens-when-a-job-znode-is-not-deleted"></a><a href="#what-happens-when-a-job-znode-is-not-deleted" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What happens When a Job znode is not deleted</h3>
<p>When a job znode is not deleted after the completion of a job, it can be deleted when a new job is submitted with the same name.
Or when a terminate job command is executed for that job.</p>
<h2><a class="anchor" aria-hidden="true" id="assigning-unique-worker-ids"></a><a href="#assigning-unique-worker-ids" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Assigning Unique Worker IDs</h2>
<p>We use DistributedAtomicInteger class of Curator library to assign unique IDs to workers. This class provides a shared integer counter that is attached to a znode on the ZooKeeper server and shared by all workers in a job. When a worker joins the job, it increases its value by one and uses the previous value as its unique ID. Since the increment operation is atomic, no two workers can get the same ID. We assign this ID only after a successful increment of the shared variable. The counter starts from zero. So, the first worker gets the ID zero.</p>
<h3><a class="anchor" aria-hidden="true" id="getting-worker-ids-after-failures"></a><a href="#getting-worker-ids-after-failures" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Getting Worker IDs after Failures</h3>
<p>When a worker rejoins a job, it is assigned its previous ID. This prevents ID sequences to have gaps in them in the case of failures.</p>
<p>When a worker joins a job, it first checks the body of the job znode. If there is an entry with this workers : pair, it means that this worker is rejoining the job after a failure. It uses the workerID from that line in the job znode body. It does not generate a new unique ID for itself.</p>
<p>If there is no : pair for this worker in the body of the job znode, then it generates a new ID and posts it to the job znode body.</p>
<h2><a class="anchor" aria-hidden="true" id="waiting-workers-on-a-barrier"></a><a href="#waiting-workers-on-a-barrier" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Waiting Workers on a Barrier</h2>
<p>We use DistributedBarrier class of Curator library to make workers wait on a barrier point. However, this class does not support the number of workers to wait. We need to watch the waiting workers and signal the barrier to release the workers, when all workers arrived at the barrier.</p>
<p>We use a DistributedAtomicInteger object from Curator library to count the number of waiting workers on the barrier point. Each worker increases the value of this counter by one, when they come to the barrier point. After increasing this distributed counter, they start to wait on the distributed barrier object. The last worker to arrive at the barrier point, does not wait. Instead, it tells the barrier object to release all waiting workers.</p>
<p>The last worker checks the value of the distributed counter, and if the counter value is a multiple of the numberOfWorkers in the job, it understands that it is the last worker.</p>
<p>Workers can wait multiple times on the barrier points during a job lifetime.</p>
<h2><a class="anchor" aria-hidden="true" id="trying-to-create-a-job-when-another-running"></a><a href="#trying-to-create-a-job-when-another-running" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Trying to Create a Job When Another Running</h2>
<p>When a Twister2 job is submitted by the client, submitting client first must check whether there is a znode created for that job name on the ZooKeeper server. If there is a znode with the same job name, there are two possibilities:</p>
<ul>
<li>Another job with the same name may be running</li>
<li>Previously submitted and completed job is not cleaned properly</li>
</ul>
<p>If the job znode has some children, it can be assumed that there is a job already running on the cluster with the same name. Job submission must fail. The user can resubmit the job with another name, or can wait until the running job to complete.</p>
<p>If the job znode does not have any children, it means that a previously executed job is not cleaned properly from ZooKeeper server. Job submitting client can remove that job znode automatically and proceed with the job submission.</p>
<p>We provide a utility class to check whether there is a job znode on the ZooKeeper server and delete the job related znodes if necessary:</p>
<pre><code class="hljs css language-text">edu.iu.dsc.tws.rsched.bootstrap.ZKUtil
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="implementation-details"></a><a href="#implementation-details" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Implementation Details:</h2>
<p>We use Apache Curator software to connect and manage communication between workers and the ZooKeeper server.</p>
<h3><a class="anchor" aria-hidden="true" id="children-cache"></a><a href="#children-cache" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Children Cache</h3>
<p>Curator library implements a client side cache of a znode children:</p>
<pre><code class="hljs css language-text">org.apache.curator.framework.recipes.cache.PathChildrenCache
</code></pre>
<p>This cached children of a znode keeps an up-to date copy of the znode children in the client machine. In our case, each worker registers with the job znode and keeps a local copy of other worker znodes in the local. Therefore each worker keeps an up-to date list of all other workers in the job.</p>
<h3><a class="anchor" aria-hidden="true" id="distributed-atomic-counter"></a><a href="#distributed-atomic-counter" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Distributed Atomic Counter</h3>
<p>Curator library implements a distributed atomic counter:</p>
<pre><code class="hljs css language-text">org.apache.curator.framework.recipes.atomic.DistributedAtomicInteger
</code></pre>
<p>It provides a shared counter that is attached to a znode. We create a znode for this counter with “-dai” postfix: -dai</p>
<h3><a class="anchor" aria-hidden="true" id="distributed-lock"></a><a href="#distributed-lock" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Distributed Lock</h3>
<p>Curator library provides a distributed lock class:</p>
<pre><code class="hljs css language-text">org.apache.curator.framework.recipes.locks.InterProcessMutex
</code></pre>
<p>The lock is attached to a znode on the server. No two clients can acquire a lock attached to the same znode. Workers acquire the shared lock to update the job znode body.</p>
<p>Since more than one worker may update the body of the job znode concurrently, workers required to acquire this lock before updating the job znode body.<br>
They release the lock after they updated it.</p>
<h2><a class="anchor" aria-hidden="true" id="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p>When a worker starts, it first needs to create an instance of ZKWorkerController class and initialize it by calling its initialize method. Then, it can get its unique ID by calling getWorkerNetworkInfo() method of ZKWorkerController object.</p>
<p>It can call getWorkerList() method of ZKWorkerController object to get the list of currently joined workers immediately. Or, if it needs the full list of workers in the job. Then, it can call waitForAllWorkersToJoin(timeLimit) method of ZKWorkerController object. This method will wait until either getting the full list of workers in the job or the time limit has been reached.</p>
<p>A sample usage can be found in the class:</p>
<pre><code class="hljs css language-text">edu.iu.dsc.tws.examples.internal.bootstrap.ZKControllerExample.java
</code></pre>
<p>Its usage in the following class can also be examined for real usage:</p>
<pre><code class="hljs css language-text">edu.iu.dsc.tws.rsched.schedulers.aurora.AuroraWorkerStarter
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="configuration-parameters"></a><a href="#configuration-parameters" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Configuration Parameters</h3>
<p>Following configuration parameters must be specified in the configuration files:</p>
<pre><code class="hljs css language-text">List of ZooKeeper server IP:port value: twister2.zookeeper.server.addresses
Example value: "127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002"
</code></pre>
<p>Following configuration parameters have default values and their default values can be overridden in the configuration files:</p>
<p>Root znode name is by default: &quot;/twister2&quot; It can be changed with the configuration parameter:</p>
<pre><code class="hljs css language-text">twister2.zookeeper.root.node.path
</code></pre>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#assumptions">Assumptions</a></li><li><a href="#main-idea">Main Idea</a><ul class="toc-headings"><li><a href="#removing-worker-znodes-from-zookeeper-server">Removing Worker Znodes from ZooKeeper Server</a></li><li><a href="#removing-job-znode-from-zookeeper-server">Removing Job Znode from ZooKeeper Server</a></li><li><a href="#failing-to-remove-the-job-znode">Failing to Remove the Job Znode</a></li><li><a href="#what-happens-when-a-job-znode-is-not-deleted">What happens When a Job znode is not deleted</a></li></ul></li><li><a href="#assigning-unique-worker-ids">Assigning Unique Worker IDs</a><ul class="toc-headings"><li><a href="#getting-worker-ids-after-failures">Getting Worker IDs after Failures</a></li></ul></li><li><a href="#waiting-workers-on-a-barrier">Waiting Workers on a Barrier</a></li><li><a href="#trying-to-create-a-job-when-another-running">Trying to Create a Job When Another Running</a></li><li><a href="#implementation-details">Implementation Details:</a><ul class="toc-headings"><li><a href="#children-cache">Children Cache</a></li><li><a href="#distributed-atomic-counter">Distributed Atomic Counter</a></li><li><a href="#distributed-lock">Distributed Lock</a></li></ul></li><li><a href="#usage">Usage</a><ul class="toc-headings"><li><a href="#configuration-parameters">Configuration Parameters</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/logo_large.png" alt="Twister2" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/quickstart.html">Getting Started (Quickstart)</a><a href="/docs/en/developing_twister2.html">Guides (Programming Guides)</a></div><div><h5>Community</h5><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://dsc-twister.slack.com/">Project Chat</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/DSC-SPIDAL/twister2">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2019 Indiana University</section></footer></div></body></html>